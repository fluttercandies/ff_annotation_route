/*
 * @Author: zmtzawqlp
 * @Date: 2020-11-08 16:22:44
 * @Last Modified by: zmtzawqlp
 * @Last Modified time: 2020-11-08 16:54:21
 */

import 'dart:io' as io;

import 'package:ff_annotation_route_core/ff_annotation_route_core.dart';
import 'package:path/path.dart' as p;

import '/src/arg/args.dart';
import '/src/route_info/route_info_base.dart';
import '/src/utils/camel_under_score_converter.dart';
import '/src/utils/dart_type_auto_import.dart';
import '/src/utils/route_interceptor.dart';
import 'file_info.dart';
import 'template.dart';
import 'utils/convert.dart';
import 'utils/format.dart';

const String _required = 'import \'package:flutter/foundation.dart\';';

class RoutesFileGenerator {
  RoutesFileGenerator({
    this.routes,
    required this.lib,
    required this.packageName,
  });

  final List<RouteInfoBase>? routes;
  final io.Directory lib;
  final String packageName;

  void generateRoutesFile() {
    final RegExp? constIgnore = Args().constIgnoreRegExp;
    final StringBuffer constantsSb = StringBuffer();
    final file = RoutesFileGenerator.deleteFile(
      packageName: packageName,
      lib: lib,
    );

    //constantsSb.write(fileHeader);

    final StringBuffer routeNamesString = StringBuffer();
    final StringBuffer interceptorsString = StringBuffer();
    for (final RouteInfoBase item in routes!) {
      final String? name = safeToString(item.ffRoute.name);
      final List<RouteInterceptor>? interceptors = item.ffRoute.interceptors;
      if (interceptors != null && interceptors.isNotEmpty) {
        interceptorsString.write(
          '$name:<RouteInterceptor>[${interceptors.map((RouteInterceptor e) {
            final FFRouteInterceptor ffRouteInterceptor =
                e as FFRouteInterceptor;
            String? className = ffRouteInterceptor.className;
            if (className == null) {
              final dartType = ffRouteInterceptor.dartType!;
              final String name =
                  dartType.getDisplayString(withNullability: false);
              final import = DartTypeAutoImportHelper().getImport(dartType);
              className = '${import?.prefix}.$name';
            }
            return '$className()';
          }).join(',')}],',
        );
      }
      if (constIgnore != null && constIgnore.hasMatch(item.ffRoute.name)) {
        continue;
      }
      routeNamesString.write(name);
      routeNamesString.write(',');
    }
    if (routeNamesString.isNotEmpty) {
      String routeNames = 'routeNames';
      if (Args().isPackage) {
        routeNames = '${camelName(packageName)}RouteNames';
      }
      constantsSb.write(
        '/// The routeNames auto generated by '
        'https://github.com/fluttercandies/ff_annotation_route\n',
      );
      constantsSb.write(
        'const List<String> $routeNames = '
        '<String>[${routeNamesString.toString()}];',
      );
      constantsSb.write('\n');
    }
    final Set<String> imports = <String>{};
    if (interceptorsString.isNotEmpty) {
      String routeInterceptorNames = 'routeInterceptors';
      if (Args().isPackage) {
        routeInterceptorNames = '${camelName(packageName)}RouteInterceptors';
      }
      constantsSb.write(
        '/// The routeInterceptors auto generated by '
        'https://github.com/fluttercandies/ff_annotation_route\n',
      );
      constantsSb.write(
        'const Map<String,List<RouteInterceptor>> $routeInterceptorNames = '
        '<String,List<RouteInterceptor>>{${interceptorsString.toString()}};',
      );
      constantsSb.write('\n');
      imports.add(
        'import \'package:ff_annotation_route_library/ff_annotation_route_library.dart\';',
      );
    }

    if (constantsSb.isEmpty) {
      constantsSb.write(fileHeader);
    }
    final className = Args().className;
    constantsSb.write(
      '/// The routes auto generated by '
      'https://github.com/fluttercandies/ff_annotation_route\n',
    );
    constantsSb.write('class $className {\n');
    constantsSb.write('const $className._();\n');

    final bool enableSuperArguments = Args().enableSuperArguments;
    for (final RouteInfoBase it in routes!) {
      if (constIgnore != null && constIgnore.hasMatch(it.ffRoute.name)) {
        continue;
      }
      it.getRouteConst(enableSuperArguments, constantsSb);
    }
    constantsSb.write('}');

    if (enableSuperArguments) {
      for (final RouteInfoBase it in routes!) {
        if (it.argumentsClass != null) {
          if (constIgnore != null && constIgnore.hasMatch(it.ffRoute.name)) {
            continue;
          }
          constantsSb.write(it.argumentsClass);
          if (!Args().enableNullSafety &&
              it.argumentsClass!.contains('@required')) {
            imports.add(_required);
          }
          if (it.argumentsClass!.contains('Key')) {
            imports.add(_required);
          }
          if (it.ffRoute.argumentImports != null &&
              it.ffRoute.argumentImports!.isNotEmpty) {
            imports.addAll(it.ffRoute.argumentImports!);
          }
        }
      }
      imports.addAll(DartTypeAutoImportHelper().imports);
      imports.addAll(FileInfo.imports);
    }

    String? constants;

    if (constantsSb.isNotEmpty) {
      constants = constantsSb.toString();

      if (imports.isNotEmpty) {
        final StringBuffer sb = StringBuffer();
        writeImports(imports, sb);
        constants = sb.toString() + constants;
      }
      constants = fileHeader + constants;
    }

    if (constants != null) {
      file.createSync(recursive: true);
      file.writeAsStringSync(
        formatDart(content: constants, directory: lib.path),
      );
      print('Generate : ${p.relative(file.path, from: lib.parent.path)}');
    }
  }

  static io.File deleteFile({
    required String packageName,
    required io.Directory lib,
  }) {
    final String? routesFileOutputPath = Args().routesFileOutputPath;
    String g = '';
    if (Args().gSuffix.value == true) {
      g = '.g';
    }
    final String name = '${packageName}_routes$g.dart';
    String routePath;

    if (routesFileOutputPath != null) {
      routePath = p.join(lib.path, routesFileOutputPath, name);
    } else {
      routePath = p.join(lib.path, name);
    }

    final file = io.File(routePath);
    if (file.existsSync()) {
      file.deleteSync();
    }
    return file;
  }
}
